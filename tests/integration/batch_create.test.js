const request = require('supertest');
const app = require('../../index');
const turso = require('../../db');

// Mock Clerk authentication
jest.mock('@clerk/express', () => ({
    clerkMiddleware: jest.fn(() => (req, res, next) => next()),
    requireAuth: jest.fn(() => (req, res, next) => {
        req.auth = { userId: 'user_test123' };
        next();
    }),
    getAuth: jest.fn(() => ({ userId: 'user_test123' }))
}));

// Mock the AI service (even though this test doesn't hit it directly, it's safe to keep mocked for app)
jest.mock('../../services/ai.service', () => ({
    generateProjectEndpoints: jest.fn(),
    generateMockData: jest.fn()
}));

const mockBatchPayload = {
    name: "Batch AI API",
    description: "Generated by AI",
    isPublic: false,
    endpoints: [
        {
            method: "GET",
            route: "/posts",
            description: "Get all posts",
            scenarios: [
                {
                    name: "Success Scenario",
                    status: 200,
                    responseBody: [{ id: 1, title: 'Hello World' }]
                },
                {
                    name: "Error Scenario",
                    status: 500,
                    responseBody: { error: "Failed" }
                }
            ]
        },
        {
            method: "POST",
            route: "/posts",
            description: "Create a post",
            scenarios: [
                {
                    name: "Created",
                    status: 201,
                    responseBody: { id: 2, title: 'New Post' }
                }
            ]
        }
    ]
};

describe('Projects API - Batch Create', () => {

    let createdProjectId;

    afterAll(async () => {
        // Cleanup the database after tests
        if (createdProjectId) {
            await turso.execute('DELETE FROM projects WHERE project_id = ?', [createdProjectId]);
        }
    });

    describe('POST /projects/batch-create', () => {
        it('should create a project with all endpoints and scenarios', async () => {
            const response = await request(app)
                .post('/projects/batch-create')
                .send(mockBatchPayload)
                .expect(201);

            expect(response.body).toHaveProperty('data');
            expect(response.body.data).toHaveProperty('project_id');
            expect(response.body.data.name).toBe(mockBatchPayload.name);

            createdProjectId = response.body.data.project_id;

            // Verify the Mocks were created
            const mocksResult = await turso.execute(
                'SELECT * FROM mocks WHERE project_id = ? ORDER BY path ASC',
                [createdProjectId]
            );

            expect(mocksResult.rows.length).toBe(2);

            const getPostsMock = mocksResult.rows.find(m => m.method === 'GET');
            const postPostsMock = mocksResult.rows.find(m => m.method === 'POST');

            expect(getPostsMock).toBeDefined();
            expect(postPostsMock).toBeDefined();

            // Verify Scenarios were created for GET /posts
            const getResponses = await turso.execute(
                'SELECT * FROM mock_responses WHERE mock_id = ? ORDER BY status_code ASC',
                [getPostsMock.mock_id]
            );

            expect(getResponses.rows.length).toBe(2);

            // Verify the default was set correctly (The 200 one should be default)
            const successResponse = getResponses.rows.find(r => r.status_code === 200);
            const errorResponse = getResponses.rows.find(r => r.status_code === 500);

            expect(successResponse.is_default).toBe(1);
            expect(errorResponse.is_default).toBe(0);

            // Verify the body was stringified
            expect(successResponse.body).toBe(JSON.stringify([{ id: 1, title: 'Hello World' }]));

            // Verify Scenarios for POST /posts
            const postResponses = await turso.execute(
                'SELECT * FROM mock_responses WHERE mock_id = ?',
                [postPostsMock.mock_id]
            );

            expect(postResponses.rows.length).toBe(1);
            expect(postResponses.rows[0].status_code).toBe(201);
            expect(postResponses.rows[0].is_default).toBe(1);
        });

        it('should return 400 if name is missing', async () => {
            const payload = { ...mockBatchPayload, name: undefined };
            const response = await request(app)
                .post('/projects/batch-create')
                .send(payload)
                .expect(400);

            expect(response.body).toHaveProperty('error', 'name is required');
        });

        it('should return 400 if endpoints is missing or not an array', async () => {
            const payload = { ...mockBatchPayload, endpoints: "not an array" };
            const response = await request(app)
                .post('/projects/batch-create')
                .send(payload)
                .expect(400);

            expect(response.body).toHaveProperty('error', 'endpoints array is required');
        });
    });
});
